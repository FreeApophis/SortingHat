
using SortingHat.API.Models;
using Xunit;

namespace SortingHat.Test
{
    public class TagTest
    {
        //[Fact]
        //public void TagEquivalence()
        //{
        //    var tag1 = new Tag("2018", new Tag("created"));
        //    var tag2 = new Tag("2018", new Tag("created"));
        //    var tag3 = new Tag("2018");

        //    Assert.Equal(tag1, tag2);
        //    Assert.NotEqual(tag1, tag3);
        //}

        //[Fact]
        //public void ParseSimpleTag()
        //{
        //    var referenceTag = new Tag("tag");
        //    Tag parsedTag = Tag.Parse(":tag");

        //    Assert.Equal(referenceTag, parsedTag);
        //}

        //[Fact]
        //public void ParseSimpleTagMissingColon()
        //{
        //    Tag referenceTag = null ;
        //    Tag parsedTag = Tag.Parse("tag");

        //    Assert.Equal(referenceTag, parsedTag);
        //}


        //[Fact]
        //public void ParseTag()
        //{
        //    var referenceTag = new Tag("child", new Tag("father", new Tag("grandfather")));
        //    Tag parsedTag = Tag.Parse(":grandfather:father:child");

        //    Assert.Equal(referenceTag, parsedTag);
        //}


        //[Fact]
        //public void ParseEmptyTag()
        //{
        //    Tag referenceTag = null;
        //    Tag parsedTag = Tag.Parse(":");

        //    Assert.Equal(referenceTag, parsedTag);
        //}

        //[Fact]
        //public void ParseTagMissingColon()
        //{
        //    Tag referenceTag = null;
        //    Tag parsedTag = Tag.Parse("grandfather:father:child");

        //    Assert.Equal(referenceTag, parsedTag);
        //}

        //[Fact]
        //public void ParseTagWhitespace()
        //{
        //    Tag referenceTag = null;
        //    Tag parsedTag = Tag.Parse("grand father:father:child with whitespace");

        //    Assert.Equal(referenceTag, parsedTag);
        //}
    }
}
